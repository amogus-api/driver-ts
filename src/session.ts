// Handles sessions, transactions and related stateful things

import * as common from "./common";
import * as things from "./things";
import * as segment from "./segment";
import { FieldValue } from "./repr";
import { NotNull } from "./common";

// Confirmation callback type
export type ConfCallback<T extends things.Method> =
    (data: T["spec"]["confirmations"][number]) =>
   Promise<T["spec"]["confirmations"][number]["response"]>;

// The "meat" of the event
export type IncompleteTransactionEvent =
    { type: "created" } |
    { type: "inbound", segment: segment.Segment } |
    { type: "outbound", segment: segment.Segment } |
    { type: "finished" };

// Adds the `tran` field to every event type
export type TransactionEvent = IncompleteTransactionEvent & { tran: Transaction };

// Manages a single transaction (generally a method call). Transactions are further
// broken down into segments.
// Note that this class has no idea about what (in the semantic sense) is being
// sent inside the segments  it manages. All meaning is state-dependent and managed
// by a Session.
export class Transaction extends common.EventHost<TransactionEvent> {
    session: Session;
    id: number;
    segments: segment.Segment[] = [];

    constructor(session: Session, id: number) {
        super();
        this.session = session;
        this.id = id;
    }

    // Determines whether or not a sequence of exchanged segments in the
    // context of this transaction is sufficient to deem this transaction
    // "complete". Valid segment within a transaction sequences are:
    // InvokeMethod -> (ConfReq -> ConfResp)* -> MethodRet|MethodErr
    // EntityUpdate
    finalized() {
        const first = this.segments[0];
        const last = [...this.segments].reverse()[0];

        if(first instanceof segment.InvokeMethodSegment)
            return (last instanceof segment.MethodReturnSegment) || (last instanceof segment.MethodErrorSegment);

        if(first instanceof segment.EntityUpdateSegment)
            return true;

        return false;
    }

    notify(data: IncompleteTransactionEvent) {
        this.trigger({ ...data, tran: this });
    }
}

// An invocation event generated by a Session
export class InvocationEvent<M extends NotNull<things.Method, "params"> = NotNull<things.Method, "params">> {
    readonly type = "method_invocation";
    method: M;

    // The underlying "new transaction" session event
    private event: TranSessionEvent;
    private session: Session;

    constructor(event: TranSessionEvent, session: Session) {
        const methInvoke = event.transaction.segments[0] as segment.InvokeMethodSegment;

        this.event = event;
        this.session = session;
        // @ts-expect-error it's okay
        this.method = methInvoke.payload;
        this.method.sessionEvent = this;
    }

    // Follows up with a ConfRequest segment and waits for a ConfResponse
    async confirm<C extends things.Confirmation>(conf: C, data: C["request"]) {
        await this.session.writeSegment(new segment.ConfRequestSegment(this.event.transaction.id,
            { ...conf, request: data }));

        // wait for response
        const response = await new Promise<C["response"]>((resolve) => {
            const cb = (event: TransactionEvent) => {
                if(event.type !== "inbound")
                    return;
                if(!(event.segment instanceof segment.ConfResponseSegment))
                    return;

                this.event.transaction.unsubscribe(cb);
                resolve(event.segment.payload.response);
            };
            this.event.transaction.subscribe(cb);
        }) as NonNullable<C["response"]>;

        return response;
    }

    // Follows up with a MethodErr segment
    async error(code: number, message: string): Promise<void> {
        await this.session.writeSegment(new segment.MethodErrorSegment(this.event.transaction.id,
            { code, msg: message }));
    }

    // Follows up with a MethodRet segment
    async return(ret: M["returnVal"]): Promise<void> {
        this.method.returnVal = ret;
        await this.session.writeSegment(new segment.MethodReturnSegment(this.event.transaction.id, this.method));
    }
}

// Session events
export type TranSessionEvent = { type: "new_transaction", transaction: Transaction };
export type EntityEvent = { type: "entity_update", entity: things.ValuedEntity };
export type CloseEvent = { type: "close" };
export type SessionEvent = TranSessionEvent | InvocationEvent | EntityEvent | CloseEvent;

// Manages all session state. A Session is an isolated server-client conversation. It's further
// broken down into Transactions that encapsulate individual requests within the session, which
// are further broken down into Segments that make up a bidirectional dialogue between the
// parties.
export abstract class Session<Gen extends things.SpecSpaceGen = things.SpecSpaceGen> extends common.EventHost<SessionEvent> {
    specSpace: things.SpaceOfGen<Gen>;
    transactions: Transaction[] = [];

    protected stream: common.Duplex;
    private self: common.PeerType;
    private active = false;

    constructor(specSpace: Gen, stream: common.Duplex, self: common.PeerType) {
        super();
        // generate a spec space bound to our session
        const space = specSpace(this) as things.SpaceOfGen<Gen>;

        this.subscribe((e) => this.processTran(e));
        this.specSpace = space;
        this.stream = stream;
        this.self = self;
        this.run();

        // destroy ourselves when the underlying stream closes
        this.stream.subscribe(async (e) => {
            if(e.type !== "closed" || !this.active)
                return;
            await this.stop();
        });
    }

    // Processes new transactions
    private async processTran(event: SessionEvent) {
        if(event.type !== "new_transaction")
            return;
        const segm = event.transaction.segments[0];

        if(segm instanceof segment.InvokeMethodSegment) {
            this.trigger(new InvocationEvent(event, this));
        } else if(segm instanceof segment.EntityUpdateSegment) {
            this.trigger({ type: "entity_update", entity: segm.payload });
        }
    }

    // Reads segments in an infinite loop
    private run() {
        const cycle: () => void = () => {
            if(!this.active)
                return;
            void this.readSegment().then((_) => cycle());
        };
        this.active = true;
        cycle();
    }

    // Stops the reading of the segments and closes the underlying link
    async stop() {
        if(!this.active)
            return;
        this.trigger({ type: "close" });
        this.active = false;
        await this.stream.close();
    }

    // Reads one segment and processes it
    async readSegment(): Promise<segment.Segment> {
        const segm = await segment.Segment.read(this, this.stream, this.self);

        // add the segment to its transaction
        let transaction = this.transactions.find(x => x.id === segm.transactionId);
        // create the object for new transactions
        let created = false;
        if(!transaction) {
            transaction = new Transaction(this, segm.transactionId);
            this.transactions.push(transaction);
            created = true;
        }
        transaction.segments.push(segm);
        if(created)
            this.trigger({ type: "new_transaction", transaction });
        transaction.notify({ type: "inbound", segment: segm });

        // remove the transaction if it's finished
        if(transaction.finalized()) {
            const id = transaction.id;
            this.transactions = this.transactions.filter(x => x.id !== id);
            transaction.notify({ type: "finished" });
        }

        return segm;
    }

    // Writes one segment
    async writeSegment(segm: segment.Segment): Promise<void> {
        const transaction = this.transactions[segm.transactionId];
        transaction.segments.push(segm);
        transaction?.notify({ type: "outbound", segment: segm });

        await segm.write(this.stream);

        // remove the transaction if it's finished
        if(transaction.finalized()) {
            this.transactions = this.transactions.filter(x => x.id !== transaction.id);
            transaction.notify({ type: "finished" });
        }
    }

    // Creates a transaction based on its initial segment
    async createTransaction(initSegment: segment.Segment): Promise<Transaction> {
        // get the first free id
        const allIds = this.transactions.map(x => x.id);
        const freeIds = Array.from({ length: 256 }, (_, i) => i).filter(id => !(id in allIds));
        if(!freeIds.length)
            throw new Error("All transaction slots are taken");
        const id = freeIds[0];

        // create the transaction and remember it
        const transaction = new Transaction(this, id);
        initSegment.transactionId = id;
        this.transactions.push(transaction);
        transaction.notify({ type: "created" });
        await this.writeSegment(initSegment);
        return transaction;
    }

    // Invokes a method, processes confirmation requests, sends confirmation responses
    // and either:
    //   a) returns the return value
    //   b) throws a server-defined error
    async invokeMethod<T extends things.Method>(
        method: T,
        confirmationCallback?: ConfCallback<T>
    ): Promise<FieldValue<T["spec"]["returns"]>> {
        if(this.self !== "client")
            throw new Error("invokeMethod can only be called on the client");

        return new Promise((resolve, reject) => {
            // create a transaction starting with an InvokeMethod segment
            void this.createTransaction(new segment.InvokeMethodSegment(0, method)).then((t) => t.subscribe((event) => {
                // react to inbound segments
                if(event.type === "inbound") {
                    if(event.segment instanceof segment.ConfRequestSegment) {
                        // invoke the callback for confirmation requests
                        if(!confirmationCallback) {
                            reject(new Error("no confirmationCallback supplied but a ConfRequest segment was received"));
                            return;
                        }
                        // we can be sure about type correctness because the decoder checked it
                        const payload = event.segment.payload;
                        void confirmationCallback(payload)
                            .then((response) => {
                                payload.response = response;
                                void this.writeSegment(new segment.ConfResponseSegment(event.tran.id, payload));
                            });
                    } else if(event.segment instanceof segment.MethodReturnSegment) {
                        // we can be just as sure here
                        resolve(event.segment.payload.returnVal as unknown as FieldValue<T["spec"]["returns"]>);
                    } else if(event.segment instanceof segment.MethodErrorSegment) {
                        // throw an error
                        reject({ code: event.segment.payload.code, message: event.segment.payload.msg });
                    }
                }
            }));
        });
    }

    // Pushes an entity on the client
    async pushEntity(entity: things.ValuedEntity): Promise<void> {
        if(this.self !== "server")
            throw new Error("pushEntity can only be called on the server");

        await this.createTransaction(new segment.EntityUpdateSegment(0, entity));
    }
}

export interface BoundSession {
    session: Session;
}
